<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RUIAN Address Widget Demo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            /* Prevent body scroll, use inner scrolling */
        }

        body {
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
        }

        /* Main application container acting as the flex wrapper */
        .app-wrapper {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 1rem;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        /* Header Section (Fixed Height) */
        .header-section {
            flex: 0 0 auto;
            margin-bottom: 1rem;
        }

        /* Main Content Section (Grow to fill space) */
        .content-section {
            flex: 1;
            display: flex;
            gap: 1.5rem;
            min-height: 0;
            /* Crucial for scrolling inner elements properly */
        }

        /* --- LEFT PANEL --- */
        .left-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 0;
            /* Fix for flex items overflowing */
        }

        .card-config {
            flex: 0 0 auto;
            /* Don't grow/shrink */
        }

        .card-address {
            flex: 1;
            /* Take remaining height */
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .card-address .card-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Container for scrollable content */
        }

        .form-area {
            flex: 0 0 auto;
            /* Form inputs take natural height */
        }

        .output-area {
            flex: 1;
            /* JSON output takes remaining height */
            display: flex;
            flex-direction: column;
            min-height: 0;
            margin-top: 1rem;
        }

        #json-output {
            flex: 1;
            background-color: #f1f3f5;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.85rem;
            border: 1px solid #dee2e6;
            overflow-y: auto;
            /* Scrollable JSON */
            margin-bottom: 0;
        }

        /* --- RIGHT PANEL --- */
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .card-debug {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            height: 100%;
        }

        .card-debug .card-body {
            flex: 1;
            padding: 0;
            background-color: #212529;
            position: relative;
            display: flex;
            flex-direction: column;
            /* Added overflow hidden to prevent container expansion */
            overflow: hidden;
        }

        /* Console Log Styles */
        #debug-console {
            flex: 1;
            overflow-y: auto;
            /* Ensures scrollbar appears */
            padding: 1rem;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            color: #e9ecef;
            white-space: pre-wrap;
            height: 100%;
            /* Added max-height to reinforce scrolling behavior */
            max-height: 100%;
        }

        /* Custom Scrollbar for dark theme */
        #debug-console::-webkit-scrollbar {
            width: 10px;
        }

        #debug-console::-webkit-scrollbar-track {
            background: #2c3034;
        }

        #debug-console::-webkit-scrollbar-thumb {
            background: #495057;
            border-radius: 5px;
        }

        #debug-console::-webkit-scrollbar-thumb:hover {
            background: #6c757d;
        }

        /* --- SHARED STYLES --- */
        .card {
            border: 1px solid rgba(0, 0, 0, .125);
            box-shadow: 0 .125rem .25rem rgba(0, 0, 0, .075);
            border-radius: 0.5rem;
        }

        .log-time {
            color: #6c757d;
            margin-right: 8px;
            font-size: 0.75rem;
        }

        .log-info {
            color: #61dafb;
        }

        .log-warn {
            color: #ffc107;
        }

        .log-success {
            color: #28a745;
        }

        .log-error {
            color: #ff6b6b;
        }

        .badge-type {
            width: 90px;
            display: inline-block;
            text-align: center;
            margin-right: 10px;
            font-weight: 500;
        }

        /* Styling for the suggestion box */
        #suggestion-box {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1050;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
            background: white;
            border: 1px solid rgba(0, 0, 0, .125);
            border-radius: 0.25rem;
        }

        .suggestion-item {
            cursor: pointer;
            border-left: 0;
            border-right: 0;
        }

        .suggestion-item:first-child {
            border-top: 0;
        }

        .suggestion-item.active,
        .suggestion-item:hover {
            background-color: #e9ecef;
            color: #1e2125;
            z-index: 1;
        }

        .suggestion-item.suggestion-complete {
            background-color: #f0fff4;
            border-left: 4px solid #198754 !important;
        }

        .suggestion-item.suggestion-complete.active {
            background-color: #c3e6cb;
            color: #0f5132;
        }

        /* Responsive Fallback for Mobile */
        @media (max-width: 991px) {

            html,
            body {
                height: auto;
                overflow: auto;
            }

            .content-section {
                flex-direction: column;
                height: auto;
            }

            .card-address,
            .card-debug {
                min-height: 500px;
                /* Fallback height for stacked view */
            }

            #debug-console {
                min-height: 400px;
            }
        }
    </style>
</head>

<body>

    <div class="app-wrapper">
        <!-- Header -->
        <div class="header-section">
            <h1 class="display-6 mb-2">RUIAN Universal JS Library Demo</h1>
            <ul class="text-muted mb-0 small">
                <li>Universal widget for Czech address validation and construction.</li>
                <li>Get API key from <a href="https://ruian.fnx.io/" target="_blank">ruian.fnx.io</a>.</li>
                <li>Enter address as: <em>City, Street, Number</em> or <em>Street Number, ZIP City</em>.</li>
            </ul>
        </div>

        <!-- Main Content Split -->
        <div class="content-section">

            <!-- Left Panel -->
            <div class="left-panel">

                <!-- API Key Card (Fixed Height) -->
                <div class="card card-config bg-white shadow-sm">
                    <div class="card-body py-3">
                        <label class="form-label small text-uppercase text-muted fw-bold mb-1">API Key
                            Configuration</label>
                        <div class="input-group input-group-sm">
                            <input type="text" class="form-control" id="api-key-input" value=""
                                placeholder="Enter RUIAN FNX API Key">
                        </div>
                        <div class="mt-2 d-flex align-items-center gap-3">
                            <div class="d-flex align-items-center gap-2">
                                <label class="form-label small text-muted mb-0" for="cache-hours">Cache (hours):</label>
                                <input type="number" class="form-control form-control-sm" id="cache-hours" value="24"
                                    min="1" max="168" style="width: 70px;">
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-danger" id="reset-cache-btn">
                                üóëÔ∏è Reset Cache
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Address Input Card (Flexible Height) -->
                <div class="card card-address shadow-sm">
                    <div class="card-header bg-white">
                        <strong>Address Input</strong>
                    </div>
                    <div class="card-body">
                        <!-- Top Form Area -->
                        <div class="form-area">
                            <form id="address-form" autocomplete="off" onsubmit="return false;">
                                <div class="mb-3 position-relative">
                                    <label for="address-input" class="form-label">Address</label>
                                    <input type="text" class="form-control form-control-lg" id="address-input"
                                        placeholder="Start typing: municipality, street, number..." autocomplete="off">
                                    <div id="suggestion-box" class="list-group"></div>
                                    <div class="form-text text-muted mt-2">
                                        <small>Controls: <kbd>‚Üë</kbd> <kbd>‚Üì</kbd> to select, <kbd>Enter</kbd> to
                                            confirm.</small>
                                    </div>
                                </div>
                            </form>
                            <hr class="my-3">
                            <div id="result-status" class="alert alert-secondary d-flex align-items-center py-2">
                                <div class="small">Waiting for input...</div>
                            </div>
                        </div>

                        <!-- Output Area (Fills remaining space) -->
                        <div class="output-area">
                            <label class="form-label small text-uppercase text-muted fw-bold">Output Object
                                (RUIANplace)</label>
                            <pre id="json-output">{}</pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="right-panel">
                <div class="card card-debug shadow-sm">
                    <div class="card-header bg-white d-flex justify-content-between align-items-center">
                        <strong>Debug Log</strong>
                        <button class="btn btn-sm btn-outline-secondary"
                            onclick="document.getElementById('debug-console').innerHTML=''">Clear Log</button>
                    </div>
                    <div class="card-body">
                        <div id="debug-console"></div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        const API_KEY = "";

        document.getElementById("api-key-input").value = API_KEY;

        /**
         * Copy/Paste the 'RuianAddressWidget' class code here if separating files.
         * For this demo, it is included directly.
         */
        class RuianAddressWidget {
            constructor(config) {
                this.inputElement = config.inputElement;
                this.suggestionBox = config.suggestionElement;
                this.apiKey = config.apiKey;
                // Badges Labels
                if  (typeof config.badgesLabels === 'object' && config.badgesLabels !== null) {
                    this.badgesLabels = config.badgesLabels;
                }
                else {
                    this.badgesLabels ={municipality:'municipality', street:'street', place:'place', complete:'complete'}
                }                
                this.onValidationChange = config.onValidationChange || function () { };
                this.onLog = config.onLog || console.log;

                // Cache configuration
                this.cacheReset = config.cacheReset || false;
                this.cachePreservation = config.cachePreservation || 24; // hours

                this.state = {
                    municipalityId: null,
                    municipalityName: null,
                    zip: null,
                    streetName: null,
                    regionName: null
                };

                this.debounceTimer = null;
                this.suggestionsData = [];
                this.activeIndex = -1;

                // Cache for all municipalities (loaded lazily)
                this.allMunicipalities = null;
                // Cache for municipality ZIP codes (fetched on-demand)
                this.zipCache = {};
                this.municipalitiesLoading = false;

                this.init();
            }

            setApiKey(key) {
                this.apiKey = key;
                this.log("API Key updated", "INFO");
            }

            init() {
                this.log("Initializing RUIAN Widget...", "INFO");

                this.inputElement.addEventListener('input', (e) => {
                    clearTimeout(this.debounceTimer);
                    this.inputElement.classList.remove('is-valid', 'is-invalid');

                    this.debounceTimer = setTimeout(() => {
                        this.handleInput(e.target.value);
                    }, 400);
                });

                this.inputElement.addEventListener('keydown', (e) => this.handleKeydown(e));

                document.addEventListener('click', (e) => {
                    if (e.target !== this.inputElement && !this.suggestionBox.contains(e.target)) {
                        this.closeSuggestions();
                    }
                });
            }

            formatZip(zip) {
                if (!zip) return "";
                const s = String(zip).replace(/\s/g, '');
                if (s.length === 5) {
                    return `${s.substring(0, 3)} ${s.substring(3)}`;
                }
                return s;
            }

            async handleInput(value) {
                if (!value || value.trim().length < 1) {
                    this.closeSuggestions();
                    this.triggerCallback(null);
                    return;
                }

                const parts = value.split(',').map(s => s.trim());
                const currentPartIndex = parts.length - 1;
                const currentText = parts[currentPartIndex];

                if (currentPartIndex === 0 && this.state.municipalityName) {
                    const cleanVal = value.toLowerCase();
                    const cleanState = this.state.municipalityName.toLowerCase();
                    if (!cleanVal.startsWith(cleanState.substring(0, Math.min(cleanVal.length, cleanState.length)))) {
                        this.log("Resetting context (Municipality changed)", "WARN");
                        this.resetState();
                    }
                }

                await this.tryAutoSelectContext(parts);

                let suggestions = [];

                if (value.length > 5 && /\d/.test(value)) {
                    const validationResult = await this.apiValidate(value);

                    if (validationResult && validationResult.status === 'MATCH') {
                        this.log("Address is VALID (MATCH)", "SUCCESS");

                        const p = validationResult.place;
                        const formattedPlace = this.mapToRuianPlace(p);
                        this.triggerCallback(formattedPlace);

                        const streetPart = p.streetName || p.municipalityPartName || p.municipalityName;
                        let numberPart = p.cp || "";
                        if (p.co) numberPart += "/" + p.co;
                        if (p.ce) numberPart = "ev." + p.ce;

                        const postalLabel = `${streetPart} ${numberPart}, ${this.formatZip(p.zip)} ${p.municipalityName}`;

                        const normalize = (s) => s.replace(/\s+/g, ' ').trim();
                        const vNorm = normalize(value);

                        if (vNorm !== normalize(postalLabel)) {
                            suggestions.unshift({
                                type: 'complete',
                                label: postalLabel,
                                value: postalLabel,
                                data: p
                            });
                        }
                        this.renderSuggestions(suggestions);
                        return;
                    } else {
                        this.triggerCallback(false);
                    }
                }

                try {
                    if (!this.state.municipalityId || currentPartIndex === 0) {
                        const munSuggestions = await this.searchMunicipality(currentText);
                        suggestions = suggestions.concat(munSuggestions);

                        if (munSuggestions.length === 0 && parts.length > 1 && !this.state.municipalityId) {
                            const fallbackSuggestions = await this.searchMunicipality(parts[0]);
                            if (fallbackSuggestions.length > 0) {
                                suggestions = suggestions.concat(fallbackSuggestions);
                            }
                        }
                    }
                    else if (this.state.municipalityId && !this.isNumber(currentText) && currentPartIndex === 1) {
                        this.log(`Searching street in ID ${this.state.municipalityId}: "${currentText}"`, "INFO");
                        const streetSuggestions = await this.searchStreet(this.state.municipalityId, currentText);
                        suggestions = suggestions.concat(streetSuggestions);

                        if (streetSuggestions.length === 0 && currentText.trim() === "") {
                            const placeSuggestions = await this.searchPlace(
                                this.state.municipalityId,
                                null,
                                currentText
                            );
                            suggestions = suggestions.concat(placeSuggestions);
                        }
                    }
                    else if (this.state.municipalityId) {
                        const placeSuggestions = await this.searchPlace(
                            this.state.municipalityId,
                            this.state.streetName,
                            currentText
                        );
                        suggestions = suggestions.concat(placeSuggestions);
                    }
                } catch (err) {
                    this.log(`Process Error: ${err.message}`, "ERROR");
                }

                this.renderSuggestions(suggestions);
            }

            async tryAutoSelectContext(parts) {
                if (!this.state.municipalityId && parts.length > 1) {
                    const query = parts[0];
                    if (query.length > 1) {
                        const candidates = await this.searchMunicipality(query);
                        const match = candidates.find(c => c.value.toLowerCase() === query.toLowerCase());
                        if (match) {
                            this.log(`Auto-selected Municipality: ${match.label}`, "INFO");
                            this.state.municipalityId = match.data.municipalityId;
                            this.state.municipalityName = match.data.municipalityName;
                            this.state.zip = match.data.zip;
                        }
                    }
                }

                if (this.state.municipalityId && !this.state.streetName && parts.length > 2) {
                    const query = parts[1];
                    if (query.length > 0 && !this.isNumber(query)) {
                        const streets = await this.searchStreet(this.state.municipalityId, query);
                        const match = streets.find(s => s.value.toLowerCase() === query.toLowerCase());
                        if (match) {
                            this.log(`Auto-selected Street: ${match.value}`, "INFO");
                            this.state.streetName = match.value;
                        }
                    }
                }
            }

            mapToRuianPlace(p) {
                return {
                    valid: true,
                    municipalityId: p.municipalityId,
                    municipalityName: p.municipalityName,
                    municipalityPartId: p.municipalityPartId || null,
                    municipalityPartName: p.municipalityPartName || null,
                    streetName: p.streetName || null,
                    ce: p.ce || null,
                    cp: p.cp || null,
                    co: p.co || null,
                    zip: p.zip,
                    id: p.id,
                    ruianId: p.id,
                    regionId: p.regionId || null,
                    regionName: p.regionName || null,
                    originalString: this.inputElement.value
                };
            }

            async apiValidate(fullQuery) {
                if (!this.apiKey) {
                    this.log("Missing API Key!", "ERROR");
                    return null;
                }

                let url = `https://ruian.fnx.io/api/v1/ruian/validate?apiKey=${this.apiKey}`;

                const reversedFormatMatch = fullQuery.match(/^(.+?)\s+(\d+(?:\/\d+)?[a-zA-Z]?)[,\s]+(\d{3}\s?\d{2})\s+(.+)$/);

                if (reversedFormatMatch) {
                    this.log("Format detected: 'Street Number, ZIP City'", "INFO");
                    const streetRaw = reversedFormatMatch[1].trim();
                    const numberRaw = reversedFormatMatch[2].trim();
                    const zipRaw = reversedFormatMatch[3].replace(/\s/g, '');
                    const cityRaw = reversedFormatMatch[4].trim();

                    let cp = null, co = null;
                    this.parseNumber(numberRaw, (p, o) => { cp = p; co = o; });

                    url += `&municipalityName=${encodeURIComponent(cityRaw)}`;
                    url += `&street=${encodeURIComponent(streetRaw)}`;
                    url += `&zip=${zipRaw}`;
                    if (cp) url += `&cp=${cp}`;
                    if (co) url += `&co=${co}`;

                    return this.fetchJson(url);
                }

                let munName = this.state.municipalityName;
                let streetName = this.state.streetName;
                let cp = null, co = null, zip = null;

                let cleanQuery = fullQuery;
                const zipMatch = fullQuery.match(/\b\d{3}\s?\d{2}\b/);
                if (zipMatch) {
                    zip = zipMatch[0].replace(/\s/g, '');
                    cleanQuery = cleanQuery.replace(zipMatch[0], '');
                } else if (this.state.zip) {
                    zip = this.state.zip;
                }

                const rawParts = cleanQuery.split(/[,]+/).map(s => s.trim()).filter(s => s.length > 0);
                let numberFound = false;

                for (let i = 0; i < rawParts.length; i++) {
                    const part = rawParts[i];
                    const numberMatch = part.match(/(\d+(?:\/\d+)?[a-zA-Z]?)$/);

                    if (numberMatch) {
                        const extractedNumber = numberMatch[1];
                        const textBeforeNumber = part.substring(0, part.length - extractedNumber.length).trim();

                        if (textBeforeNumber.length === 0 || textBeforeNumber.length > 2) {
                            if (textBeforeNumber.length > 2 && !streetName) streetName = textBeforeNumber;
                            this.parseNumber(extractedNumber, (p, o) => { cp = p; co = o; });
                            numberFound = true;
                            rawParts[i] = null;
                        }
                        if (numberFound) break;
                    }
                }

                const remainingParts = rawParts.filter(p => p !== null);

                if (!munName && remainingParts.length > 0) {
                    if (remainingParts.length >= 2) {
                        if (!streetName) streetName = remainingParts[0];
                        munName = remainingParts[remainingParts.length - 1];
                    } else if (remainingParts.length === 1) {
                        if (streetName) {
                            munName = remainingParts[0];
                        } else {
                            if (this.state.municipalityId) streetName = remainingParts[0];
                            else munName = remainingParts[0];
                        }
                    }
                }

                if (!streetName && this.state.streetName) streetName = this.state.streetName;
                if (!munName && this.state.municipalityName) munName = this.state.municipalityName;

                if (munName) url += `&municipalityName=${encodeURIComponent(munName)}`;
                if (streetName) url += `&street=${encodeURIComponent(streetName)}`;
                if (cp) url += `&cp=${cp}`;
                if (co) url += `&co=${co}`;
                if (zip) url += `&zip=${zip}`;

                return this.fetchJson(url);
            }

            parseNumber(numStr, callback) {
                const nums = numStr.split('/');
                const cpRaw = nums[0].replace(/\D/g, '');
                if (cpRaw) callback(cpRaw, null);
                if (nums[1]) {
                    const coRaw = nums[1].replace(/\D/g, '');
                    if (coRaw) callback(cpRaw, coRaw);
                }
            }

            /**
             * LocalStorage cache key for municipalities data
             */
            getCacheKey() {
                return 'ruian_municipalities_cache';
            }

            /**
             * Check if cached data is valid (based on cachePreservation setting)
             */
            getCachedMunicipalities() {
                // If cacheReset is true, skip cache and clear it
                if (this.cacheReset) {
                    this.log("Cache reset requested, clearing cache...", "INFO");
                    localStorage.removeItem(this.getCacheKey());
                    this.cacheReset = false; // Reset flag after clearing
                    return null;
                }

                try {
                    const cached = localStorage.getItem(this.getCacheKey());
                    if (!cached) return null;

                    const data = JSON.parse(cached);
                    const now = Date.now();
                    const maxAge = this.cachePreservation * 60 * 60 * 1000; // hours to milliseconds

                    if (data.timestamp && (now - data.timestamp) < maxAge && data.municipalities) {
                        const minutesAgo = Math.round((now - data.timestamp) / 60000);
                        const hoursAgo = (minutesAgo / 60).toFixed(1);
                        this.log(`Using cached municipalities (${data.municipalities.length} items, cached ${hoursAgo}h ago, max ${this.cachePreservation}h)`, "INFO");
                        return data.municipalities;
                    }

                    this.log(`Cache expired (max age: ${this.cachePreservation}h), will reload municipalities`, "INFO");
                    return null;
                } catch (e) {
                    this.log(`Cache read error: ${e.message}`, "ERROR");
                    return null;
                }
            }

            /**
             * Save municipalities to localStorage cache
             */
            saveMunicipalitiesToCache(municipalities) {
                try {
                    const data = {
                        timestamp: Date.now(),
                        municipalities: municipalities
                    };
                    localStorage.setItem(this.getCacheKey(), JSON.stringify(data));
                    this.log(`Saved ${municipalities.length} municipalities to cache`, "SUCCESS");
                } catch (e) {
                    this.log(`Cache write error: ${e.message}`, "ERROR");
                }
            }

            /**
             * Load all municipalities from all regions (with localStorage cache for 24h)
             */
            async loadAllMunicipalities() {
                if (this.allMunicipalities) return this.allMunicipalities;

                // Try to load from localStorage cache first
                const cached = this.getCachedMunicipalities();
                if (cached) {
                    this.allMunicipalities = cached;
                    return cached;
                }

                if (this.municipalitiesLoading) {
                    // Wait for loading to complete
                    while (this.municipalitiesLoading) {
                        await new Promise(r => setTimeout(r, 100));
                    }
                    return this.allMunicipalities || [];
                }

                this.municipalitiesLoading = true;
                this.log("Loading all municipalities from all regions...", "INFO");

                try {
                    const baseUrl = 'https://ruian.fnx.io/api/v1/ruian/build/';
                    const regionsUrl = baseUrl + 'regions?apiKey=' + this.apiKey;
                    const regionsData = await this.fetchJson(regionsUrl);
                    if (!regionsData || !regionsData.data) {
                        this.municipalitiesLoading = false;
                        return [];
                    }

                    const allMunicipalities = [];

                    for (const region of regionsData.data) {
                        // Load municipalities for this region - use string concatenation to avoid &reg entity issue
                        const munUrl = baseUrl + 'municipalities?apiKey=' + this.apiKey + String.fromCharCode(38) + 'regionId=' + region.regionId;
                        const munData = await this.fetchJson(munUrl);
                        if (munData && munData.data) {
                            for (const m of munData.data) {
                                allMunicipalities.push({
                                    municipalityId: m.municipalityId,
                                    municipalityName: m.municipalityName,
                                    regionId: region.regionId,
                                    regionName: region.regionName
                                });
                            }
                        }
                    }

                    this.allMunicipalities = allMunicipalities;
                    this.log(`Loaded ${allMunicipalities.length} municipalities from API`, "SUCCESS");

                    // Save to localStorage cache
                    this.saveMunicipalitiesToCache(allMunicipalities);
                } catch (e) {
                    this.log(`Error loading municipalities: ${e.message}`, "ERROR");
                }

                this.municipalitiesLoading = false;
                return this.allMunicipalities || [];
            }

            /**
             * Format ZIP code to postal format (xxx xx)
             */
            formatZip(zip) {
                if (!zip) return null;
                const cleaned = String(zip).replace(/\s/g, '');
                if (cleaned.length === 5) {
                    return cleaned.slice(0, 3) + ' ' + cleaned.slice(3);
                }
                return cleaned;
            }

            /**
             * Fetch ZIP code for a municipality (cached) with robust fallback
             * 1. /validate?cp=1 - works if house #1 exists
             * 2. /places?streetName=- - works for villages without streets
             * 3. /streets ‚Üí /places - works for municipalities with streets
             */
            async fetchMunicipalityZip(municipalityId) {
                if (this.zipCache[municipalityId]) {
                    return this.zipCache[municipalityId];
                }

                let zip = null;

                // Try #1: /validate with cp=1 (fastest)
                try {
                    const url = 'https://ruian.fnx.io/api/v1/ruian/validate?apiKey=' + this.apiKey + String.fromCharCode(38) + 'municipalityId=' + municipalityId + String.fromCharCode(38) + 'cp=1';
                    const data = await this.fetchJson(url);
                    if (data && data.place) {
                        zip = data.place.zip || data.place.placeZip;
                    }
                } catch (e) {
                    // Ignore, try fallback
                }

                // Try #2: /places with streetName=- (for villages without streets)
                if (!zip) {
                    try {
                        const url = 'https://ruian.fnx.io/api/v1/ruian/build/places?apiKey=' + this.apiKey + String.fromCharCode(38) + 'municipalityId=' + municipalityId + String.fromCharCode(38) + 'streetName=-' + String.fromCharCode(38) + 'limit=1';
                        const data = await this.fetchJson(url);
                        if (data && data.data && data.data.length > 0) {
                            zip = data.data[0].placeZip || data.data[0].zip;
                        } else if (data && data.length > 0) {
                            zip = data[0].placeZip || data[0].zip;
                        }
                    } catch (e) {
                        // Ignore, try fallback
                    }
                }

                // Try #3: Get first street, then get place from that street (for municipalities with streets)
                if (!zip) {
                    try {
                        const streetsUrl = 'https://ruian.fnx.io/api/v1/ruian/build/streets?apiKey=' + this.apiKey + String.fromCharCode(38) + 'municipalityId=' + municipalityId + String.fromCharCode(38) + 'limit=1';
                        const streetsData = await this.fetchJson(streetsUrl);
                        const streets = streetsData && streetsData.data ? streetsData.data : streetsData;
                        if (streets && streets.length > 0) {
                            const streetName = streets[0].streetName;
                            const placesUrl = 'https://ruian.fnx.io/api/v1/ruian/build/places?apiKey=' + this.apiKey + String.fromCharCode(38) + 'municipalityId=' + municipalityId + String.fromCharCode(38) + 'streetName=' + encodeURIComponent(streetName) + String.fromCharCode(38) + 'limit=1';
                            const placesData = await this.fetchJson(placesUrl);
                            const places = placesData && placesData.data ? placesData.data : placesData;
                            if (places && places.length > 0) {
                                zip = places[0].placeZip || places[0].zip;
                            }
                        }
                    } catch (e) {
                        this.log(`Error fetching ZIP for ${municipalityId}: ${e.message}`, "ERROR");
                    }
                }

                if (zip) {
                    this.zipCache[municipalityId] = zip;
                    return zip;
                }
                return null;
            }

            /**
             * API: Search Municipality - finds all matching municipalities across all regions
             * Shows ZIP codes for municipalities with same name in same region
             */
            async searchMunicipality(query) {
                if (/^\d/.test(query) || query.length < 2 || !this.apiKey) return [];

                const municipalities = await this.loadAllMunicipalities();
                const normalized = query.toLowerCase().trim();

                // Find all municipalities that match the query
                const matches = municipalities.filter(m =>
                    m.municipalityName.toLowerCase().includes(normalized)
                );

                // Sort: exact matches first, then by name length (shorter first), then alphabetically
                matches.sort((a, b) => {
                    const aExact = a.municipalityName.toLowerCase() === normalized;
                    const bExact = b.municipalityName.toLowerCase() === normalized;
                    if (aExact && !bExact) return -1;
                    if (!aExact && bExact) return 1;

                    const aStarts = a.municipalityName.toLowerCase().startsWith(normalized);
                    const bStarts = b.municipalityName.toLowerCase().startsWith(normalized);
                    if (aStarts && !bStarts) return -1;
                    if (!aStarts && bStarts) return 1;

                    if (a.municipalityName.length !== b.municipalityName.length) {
                        return a.municipalityName.length - b.municipalityName.length;
                    }
                    return a.municipalityName.localeCompare(b.municipalityName);
                });

                // Identify duplicates: same name + same region = need ZIP to distinguish
                const nameRegionGroups = {};
                matches.forEach(m => {
                    const key = m.municipalityName.toLowerCase() + '|' + m.regionId;
                    nameRegionGroups[key] = (nameRegionGroups[key] || 0) + 1;
                });

                // Check if there are multiple municipalities with the same name (across all regions)
                const nameGroups = {};
                matches.forEach(m => {
                    const name = m.municipalityName.toLowerCase();
                    nameGroups[name] = (nameGroups[name] || 0) + 1;
                });

                // Get top 15 matches
                const topMatches = matches.slice(0, 15);

                // Fetch ZIP codes for duplicates in same region (concurrently)
                const zipPromises = topMatches.map(async m => {
                    const key = m.municipalityName.toLowerCase() + '|' + m.regionId;
                    const needsZip = nameRegionGroups[key] > 1;
                    if (needsZip) {
                        return await this.fetchMunicipalityZip(m.municipalityId);
                    }
                    return null;
                });
                const zips = await Promise.all(zipPromises);

                return topMatches.map((m, i) => {
                    const hasDuplicates = nameGroups[m.municipalityName.toLowerCase()] > 1;
                    const key = m.municipalityName.toLowerCase() + '|' + m.regionId;
                    const sameRegionDuplicates = nameRegionGroups[key] > 1;
                    const zip = zips[i];

                    // Build label based on duplication level
                    let label;
                    const formattedZip = this.formatZip(zip);
                    if (sameRegionDuplicates && formattedZip) {
                        // Same name + same region = show ZIP + region
                        label = `${m.municipalityName}, ${formattedZip} (${m.regionName})`;
                    } else if (hasDuplicates) {
                        // Same name in different regions = show region only
                        label = `${m.municipalityName} (${m.regionName})`;
                    } else {
                        // Unique name = show name only
                        label = m.municipalityName;
                    }

                    return {
                        type: 'municipality',
                        label: label,
                        value: m.municipalityName,
                        data: {
                            municipalityId: m.municipalityId,
                            municipalityName: m.municipalityName,
                            regionId: m.regionId,
                            regionName: m.regionName,
                            zip: zip
                        }
                    };
                });
            }

            async searchStreet(municipalityId, query) {
                if (!this.apiKey) return [];
                const url = `https://ruian.fnx.io/api/v1/ruian/build/streets?apiKey=${this.apiKey}&municipalityId=${municipalityId}`;
                const json = await this.fetchJson(url);

                if (!json || !json.data) return [];

                const normalized = query.toLowerCase();
                const filtered = json.data.filter(s => {
                    const name = s.streetName || s.streetLessPartName;
                    return name && name.toLowerCase().includes(normalized);
                });

                return filtered.slice(0, 10).map(s => ({
                    type: 'street',
                    label: s.streetName || s.streetLessPartName,
                    value: s.streetName || s.streetLessPartName,
                    data: s
                }));
            }

            async searchPlace(municipalityId, streetName, query) {
                if (!this.apiKey) return [];
                let url = `https://ruian.fnx.io/api/v1/ruian/build/places?apiKey=${this.apiKey}&municipalityId=${municipalityId}`;
                if (streetName) {
                    url += `&streetName=${encodeURIComponent(streetName)}`;
                }

                const json = await this.fetchJson(url);
                if (!json || !json.data) return [];

                const normalized = query.toLowerCase().trim();

                const candidates = json.data.map(p => {
                    let label = "";
                    if (p.placeCp) label += p.placeCp;
                    if (p.placeCo) label += "/" + p.placeCo;
                    if (p.placeCe) label = "ev." + p.placeCe;

                    return {
                        type: 'place',
                        label: label,
                        value: label,
                        data: p
                    };
                });

                const filtered = candidates.filter(c => {
                    if (!normalized) return true;
                    if (c.label.toLowerCase().startsWith(normalized)) return true;
                    const co = c.data.placeCo ? String(c.data.placeCo).toLowerCase() : "";
                    if (co.startsWith(normalized)) return true;
                    const cp = c.data.placeCp ? String(c.data.placeCp).toLowerCase() : "";
                    if (cp.startsWith(normalized)) return true;
                    return false;
                });

                return filtered.slice(0, 10);
            }

            async fetchJson(url) {
                const safeUrl = url.replace(this.apiKey, '***');
                this.log(`GET ${safeUrl}`, "INFO");

                try {
                    const res = await fetch(url);
                    if (!res.ok) {
                        this.log(`HTTP Error: ${res.status} ${res.statusText}`, "ERROR");
                        return null;
                    }
                    const data = await res.json();

                    let logMsg = JSON.stringify(data);
                    if (logMsg.length > 200) logMsg = logMsg.substring(0, 200) + "...";
                    this.log(`Response: ${logMsg}`, "INFO");

                    return data;
                } catch (e) {
                    this.log(`Network Error: ${e.message}`, "ERROR");
                    return null;
                }
            }

            renderSuggestions(list) {
                this.suggestionBox.innerHTML = '';
                this.suggestionsData = list;

                this.activeIndex = (list.length > 0 && list[0].type === 'complete') ? 0 : -1;

                if (!list || list.length === 0) {
                    this.closeSuggestions();
                    return;
                }

                list.forEach((item, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'list-group-item list-group-item-action suggestion-item d-flex align-items-center justify-content-between';

                    if (index === this.activeIndex) {
                        btn.classList.add('active');
                    }

                    let badgeClass = 'bg-secondary';
                    if (item.type === 'municipality') badgeClass = 'bg-primary';
                    if (item.type === 'street') badgeClass = 'bg-warning text-dark';
                    if (item.type === 'place') badgeClass = 'bg-info text-dark';
                    if (item.type === 'complete') {
                        badgeClass = 'bg-success';
                        btn.classList.add('suggestion-complete');
                    }

                    btn.innerHTML = `
                <span>${item.label}</span>
                <span class="badge ${badgeClass} badge-type">${this.badgesLabels[item.type]}</span>
            `;

                    btn.onclick = (e) => {
                        e.preventDefault();
                        this.selectSuggestion(index);
                    };

                    this.suggestionBox.appendChild(btn);
                });

                this.suggestionBox.style.display = 'block';
            }

            selectSuggestion(index) {
                const item = this.suggestionsData[index];
                if (!item) return;

                this.log(`Selected: ${item.type} - ${item.label}`, "SUCCESS");

                if (item.type === 'complete') {
                    this.inputElement.value = item.value;
                    const p = this.mapToRuianPlace(item.data);
                    this.triggerCallback(p);

                    this.state.municipalityId = item.data.municipalityId;
                    this.state.municipalityName = item.data.municipalityName;
                    this.state.zip = item.data.zip;
                    this.state.streetName = item.data.streetName || null;

                    this.closeSuggestions();
                }
                else if (item.type === 'municipality') {
                    this.state.municipalityId = item.data.municipalityId;
                    this.state.municipalityName = item.data.municipalityName;
                    this.state.zip = item.data.zip;
                    this.state.streetName = null;
                    this.state.regionName = item.data.regionName || null;

                    this.inputElement.value = `${item.data.municipalityName}, `;
                    this.handleInput(this.inputElement.value);
                    this.inputElement.focus();
                }
                else if (item.type === 'street') {
                    this.state.streetName = item.value;
                    this.inputElement.value = `${this.state.municipalityName}, ${item.value}, `;
                    this.handleInput(this.inputElement.value);
                    this.inputElement.focus();
                }
                else if (item.type === 'place') {
                    let prefix = `${this.state.municipalityName}, `;
                    if (this.state.streetName) prefix += `${this.state.streetName}, `;
                    const zip = item.data.placeZip || this.state.zip;

                    this.inputElement.value = `${prefix}${item.value}, ${this.formatZip(zip)}`;
                    this.handleInput(this.inputElement.value);
                    this.inputElement.focus();
                }
            }

            closeSuggestions() {
                if (this.suggestionBox) this.suggestionBox.style.display = 'none';
                this.activeIndex = -1;
            }

            handleKeydown(e) {
                if (!this.suggestionBox || this.suggestionBox.style.display === 'none') return;
                const items = this.suggestionBox.querySelectorAll('.suggestion-item');
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    this.activeIndex = (this.activeIndex + 1) % items.length;
                    this.highlightItem(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    this.activeIndex = (this.activeIndex - 1 + items.length) % items.length;
                    this.highlightItem(items);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (this.activeIndex > -1) this.selectSuggestion(this.activeIndex);
                } else if (e.key === 'Escape') {
                    this.closeSuggestions();
                }
            }

            highlightItem(items) {
                items.forEach(i => i.classList.remove('active'));
                if (items[this.activeIndex]) {
                    items[this.activeIndex].classList.add('active');
                    items[this.activeIndex].scrollIntoView({ block: 'nearest' });
                }
            }

            isNumber(str) {
                return /^\d/.test(str.trim());
            }

            resetState() {
                this.state = {
                    municipalityId: null,
                    municipalityName: null,
                    zip: null,
                    streetName: null,
                    regionName: null
                };
            }

            triggerCallback(data) {
                if (data === false) {
                    this.inputElement.classList.add('is-invalid');
                    this.inputElement.classList.remove('is-valid');
                    this.onValidationChange(false, null);
                } else if (data === null) {
                    this.inputElement.classList.remove('is-valid', 'is-invalid');
                    this.onValidationChange(null, null);
                } else {
                    this.inputElement.classList.remove('is-invalid');
                    this.inputElement.classList.add('is-valid');
                    this.onValidationChange(true, { RUIANplace: data });
                }
            }

            log(msg, type) {
                this.onLog(msg, type);
            }
        }

        // ==========================================
        // DEMO INITIALIZATION
        // ==========================================
        document.addEventListener('DOMContentLoaded', () => {

            // UI Elements
            const apiKeyInput = document.getElementById('api-key-input');
            const resultStatus = document.getElementById('result-status');
            const jsonOutput = document.getElementById('json-output');
            const debugConsole = document.getElementById('debug-console');

            // Helper to log to the DOM
            const domLogger = (msg, type) => {
                const time = new Date().toLocaleTimeString();
                let colorClass = 'log-info';
                if (type === 'ERROR') colorClass = 'log-error';
                if (type === 'SUCCESS') colorClass = 'log-success';
                if (type === 'WARN') colorClass = 'log-warn';

                const div = document.createElement('div');
                div.innerHTML = `<span class="log-time">${time}</span><span class="${colorClass}">[${type}]</span> ${msg}`;
                debugConsole.appendChild(div);
                debugConsole.scrollTop = debugConsole.scrollHeight;
            };

            // Callback when validation changes
            const onValidationChange = (isValid, data) => {
                if (isValid === true) {
                    resultStatus.className = 'alert alert-success d-flex align-items-center py-2';
                    resultStatus.innerHTML = '<div><strong>‚úì Valid Address</strong><br><small>Address verified in RUIAN.</small></div>';
                    jsonOutput.textContent = JSON.stringify(data, null, 4);
                } else if (isValid === false) {
                    resultStatus.className = 'alert alert-warning d-flex align-items-center py-2';
                    resultStatus.textContent = 'Address not found or incomplete.';
                    jsonOutput.textContent = '{}';
                } else {
                    resultStatus.className = 'alert alert-secondary d-flex align-items-center py-2';
                    resultStatus.textContent = 'Waiting for input...';
                    jsonOutput.textContent = '{}';
                }
            };

            // Init Widget
            const widget = new RuianAddressWidget({
                inputElement: document.getElementById('address-input'),
                suggestionElement: document.getElementById('suggestion-box'),
                apiKey: apiKeyInput.value,
                badgesLabels:{municipality:'municipality', street:'street', place:'place', complete:'complete'},                                
                onValidationChange: onValidationChange,
                onLog: domLogger
            });

            // Auto-update key on change
            apiKeyInput.addEventListener('input', () => {
                const newKey = apiKeyInput.value.trim();
                if (newKey) {
                    widget.setApiKey(newKey);
                }
            });

            // Cache preservation hours control
            const cacheHoursInput = document.getElementById('cache-hours');
            cacheHoursInput.addEventListener('change', () => {
                const hours = parseInt(cacheHoursInput.value, 10);
                if (hours >= 1 && hours <= 168) {
                    widget.cachePreservation = hours;
                    domLogger(`Cache preservation set to ${hours} hours`, 'INFO');
                }
            });

            // Reset cache button
            const resetCacheBtn = document.getElementById('reset-cache-btn');
            resetCacheBtn.addEventListener('click', () => {
                localStorage.removeItem('ruian_municipalities_cache');
                widget.allMunicipalities = null;
                widget.zipCache = {};
                domLogger('Cache cleared! Municipalities will be reloaded on next search.', 'SUCCESS');
            });
        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>